// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc319.RecyleRush.commands;

import edu.wpi.first.wpilibj.PIDController;
import edu.wpi.first.wpilibj.command.PIDCommand;

import org.usfirst.frc319.RecyleRush.Robot;
import org.usfirst.frc319.RecyleRush.RobotMap;

/**
 *
 */
public class  AutoRotateLooseToleranceWhileKeepingTote extends PIDCommand {
	double setpoint = 0;
	static double P = 0.075;
	static double I = 0.007; //Was 0.005
	static double D = 0.75;
	
    public AutoRotateLooseToleranceWhileKeepingTote(double degrees) {
    	
        super("AutoRotate", P, I, D, 0.02); // was 0.25... then 0.1
        getPIDController().setContinuous(false);
        getPIDController().setAbsoluteTolerance(1.0);
        

    
        setpoint = degrees;
        // Use requires() here to declare subsystem dependencies
        // eg. requires(chassis);
        requires(Robot.driveTrain);
        requires(Robot.activeCollector);
      
    }

    protected double returnPIDInput() {
        // Return your input value for the PID loop
        // e.g. a sensor, like a potentiometer:
        // yourPot.getAverageVoltage() / kYourMaxVoltage;

        return Robot.driveTrain.getDegreesFromEncoderValues();
    }

    protected void usePIDOutput(double output) {
        // Use output to drive your system, like a motor
        // e.g. yourMotor.set(output);
    	double limit = .8;
    	if (output < -limit){
    		output = -limit;
    	}
    	else if (output > limit){
    		output = limit;
    	}
        Robot.driveTrain.manualArcadeDrive(0, output);
    }

    // Called just before this Command runs the first time
    protected void initialize() {
    	
    	this.setSetpoint(Robot.driveTrain.getDegreesFromEncoderValues() + setpoint);
    	this.getPIDController().enable();
    	//System.out.println("I have the setpoint and it's "+ setpoint);
    }

    // Called repeatedly when this Command is scheduled to run
    protected void execute() {
    	PIDController controller = this.getPIDController();
    	if (Math.abs(controller.getError()) > 5){
    		controller.setPID(P, 0, D);    		
    	}
    	else{
    		controller.setPID(P, I, D); 
    	}
    	
    	double leftValue = Robot.elevator.getLeftDetectorValues();
    	double rightValue = Robot.elevator.getRightDetectorValues();
    	double threshold = 5.0;
    	
    	
    	if( rightValue > threshold && leftValue > threshold){   // ALL 5.5's used to just be 5's
    		Robot.activeCollector.collectRight(.5);
    		Robot.activeCollector.collectLeft(.5);
    	}else if(rightValue > threshold+2){
    		Robot.activeCollector.collectRight(.5);
    		Robot.activeCollector.collectLeft(0);
    	}else if(leftValue > threshold+2){
    		Robot.activeCollector.collectLeft(.5);
    		Robot.activeCollector.collectRight(0);
    	}else{
    		Robot.activeCollector.stop(); //Stop sets the tote presence to false, will this boolean affect auto overall?
    	}
    	
    	
    }

    // Make this return true when this Command no longer needs to run execute()
    protected boolean isFinished() {
    	return this.getPIDController().onTarget();
    }

    // Called once after isFinished returns true
    protected void end() {
    }

    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    protected void interrupted() {
    }
}
